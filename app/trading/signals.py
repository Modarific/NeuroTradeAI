"""
Signal generation module for trading strategies.
Defines Signal data models and base strategy interface.
"""
from enum import Enum
from typing import Optional, List, Dict, Any
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class SignalAction(Enum):
    """Trading signal actions."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"  # Close existing position


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    """
    symbol: str
    action: SignalAction
    confidence: float  # 0.0 to 1.0
    size_pct: float  # Percentage of account to allocate (0.0 to 1.0)
    reasoning: str  # Human-readable explanation
    timestamp: datetime
    strategy_name: str
    
    # Optional price targets
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    
    # Additional metadata
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "symbol": self.symbol,
            "action": self.action.value,
            "confidence": self.confidence,
            "size_pct": self.size_pct,
            "reasoning": self.reasoning,
            "timestamp": self.timestamp.isoformat(),
            "strategy_name": self.strategy_name,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "metadata": self.metadata
        }
    
    def __str__(self) -> str:
        return f"Signal({self.action.value.upper()} {self.symbol} @ {self.confidence:.2f} confidence: {self.reasoning})"


class BaseStrategy:
    """
    Abstract base class for trading strategies.
    All strategies must implement the generate_signals method.
    """
    
    def __init__(self, name: str, config: Optional[Dict[str, Any]] = None):
        """
        Initialize strategy.
        
        Args:
            name: Strategy name
            config: Optional configuration dictionary
        """
        self.name = name
        self.config = config or {}
        self.enabled = True
        
    def generate_signals(self, 
                        symbol: str,
                        features: Dict[str, Any],
                        current_positions: Optional[Dict[str, Any]] = None) -> List[Signal]:
        """
        Generate trading signals based on features and current positions.
        
        Args:
            symbol: Stock symbol to analyze
            features: Dictionary of computed features
            current_positions: Optional dictionary of current positions
            
        Returns:
            List of Signal objects (can be empty if no signal)
        """
        raise NotImplementedError("Subclasses must implement generate_signals()")
    
    def enable(self):
        """Enable strategy."""
        self.enabled = True
        logger.info(f"Strategy '{self.name}' enabled")
    
    def disable(self):
        """Disable strategy."""
        self.enabled = False
        logger.info(f"Strategy '{self.name}' disabled")
    
    def update_config(self, config: Dict[str, Any]):
        """Update strategy configuration."""
        self.config.update(config)
        logger.info(f"Strategy '{self.name}' configuration updated")
    
    def get_status(self) -> Dict[str, Any]:
        """Get strategy status."""
        return {
            "name": self.name,
            "enabled": self.enabled,
            "config": self.config
        }


class SignalGenerator:
    """
    Orchestrates multiple strategies and generates trading signals.
    """
    
    def __init__(self):
        """Initialize signal generator."""
        self.strategies: Dict[str, BaseStrategy] = {}
        self.active_strategy: Optional[str] = None
        
    def register_strategy(self, strategy: BaseStrategy):
        """
        Register a trading strategy.
        
        Args:
            strategy: BaseStrategy instance
        """
        self.strategies[strategy.name] = strategy
        logger.info(f"Registered strategy: {strategy.name}")
        
        # Set as active if it's the first strategy
        if self.active_strategy is None:
            self.active_strategy = strategy.name
    
    def set_active_strategy(self, strategy_name: str) -> bool:
        """
        Set the active trading strategy.
        
        Args:
            strategy_name: Name of strategy to activate
            
        Returns:
            True if successful, False otherwise
        """
        if strategy_name not in self.strategies:
            logger.error(f"Strategy '{strategy_name}' not found")
            return False
        
        self.active_strategy = strategy_name
        logger.info(f"Active strategy set to: {strategy_name}")
        return True
    
    def generate_signals(self,
                        symbol: str,
                        features: Dict[str, Any],
                        current_positions: Optional[Dict[str, Any]] = None) -> List[Signal]:
        """
        Generate signals from the active strategy.
        
        Args:
            symbol: Stock symbol to analyze
            features: Dictionary of computed features
            current_positions: Optional dictionary of current positions
            
        Returns:
            List of Signal objects
        """
        if not self.active_strategy:
            logger.warning("No active strategy set")
            return []
        
        strategy = self.strategies.get(self.active_strategy)
        if not strategy:
            logger.error(f"Active strategy '{self.active_strategy}' not found")
            return []
        
        if not strategy.enabled:
            logger.debug(f"Strategy '{strategy.name}' is disabled")
            return []
        
        try:
            signals = strategy.generate_signals(symbol, features, current_positions)
            
            if signals:
                logger.info(f"Generated {len(signals)} signal(s) from {strategy.name}")
                for signal in signals:
                    logger.debug(f"  {signal}")
            
            return signals
            
        except Exception as e:
            logger.error(f"Error generating signals from {strategy.name}: {e}")
            return []
    
    def get_all_strategies(self) -> List[Dict[str, Any]]:
        """Get list of all registered strategies with their status."""
        return [strategy.get_status() for strategy in self.strategies.values()]
    
    def get_active_strategy(self) -> Optional[BaseStrategy]:
        """Get the currently active strategy."""
        if self.active_strategy:
            return self.strategies.get(self.active_strategy)
        return None

